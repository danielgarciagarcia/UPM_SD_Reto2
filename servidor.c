/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <pwd.h>
#include <stdbool.h>
#include <grp.h>
#include <errno.h>
#include "servicio.h"

get_guid_reply *get_guid_1_svc(char **argp, struct svc_req *rqstp) {
    static get_guid_reply result;

    xdr_free((xdrproc_t) xdr_get_guid_reply, (char *) &result);

    errno = 0;
    struct group *group = getgrnam(*argp);
    if (errno != 0 || group == NULL) {
        result.guid = -1;
        result.uids.uids_len = 0;
        result.uids.uids_val = NULL;
    } else {
        result.guid = (int) group->gr_gid;
        int i;
        for (i = 0; group->gr_mem[i] != NULL; ++i) {
            struct passwd *user_info = getpwnam(group->gr_mem[i]);
            result.uids.uids_val = realloc(result.uids.uids_val, sizeof(int) * (i + 1));
            result.uids.uids_val[i] = (int) user_info->pw_uid;
        }
        result.uids.uids_len = i;
    }

    return &result;
}

get_uname_reply *get_uname_1_svc(int *argp, struct svc_req *rqstp) {
    static get_uname_reply result;

    xdr_free((xdrproc_t) xdr_get_uname_reply, (char *) &result);

    struct passwd *user_info = getpwuid(*argp);
    if (user_info == NULL) {
        result.exists = false;
    } else {
        result.exists = true;
        result.get_uname_reply_u.reply = malloc(sizeof(get_uname_reply_true));
        result.get_uname_reply_u.reply->uname = malloc(strlen(user_info->pw_name) + 1);
        strcpy(result.get_uname_reply_u.reply->uname, user_info->pw_name);

        /*
         * Due to the impossibility to know how many groups is the user member of, and that amount necessary to call
         * the getgrouplist() function, its first call is done passing 1 as the number of groups to be retrieved. This
         * way we can know via the ngroup value-result parameter, how many groups there are. Then, getgrouplist() is
         * called again to retrieve all the groups the user is member of, allocating the appropriate amount of Heap
         * memory to accommodate this information. This procedure is recommended by the function's man page.
         */
        int ngroups = 1;
        gid_t *group_list_aux = malloc(sizeof(gid_t));
        gid_t *group_list;
        int res = getgrouplist(user_info->pw_name, user_info->pw_gid, group_list_aux, &ngroups);
        if (res == -1) {
            group_list = malloc(sizeof(gid_t) * ngroups);
            getgrouplist(user_info->pw_name, user_info->pw_gid, group_list, &ngroups);
            free(group_list_aux);
        } else {
            group_list = group_list_aux;
        }


        /*
         * The resulting group list contains GIDs, but the function must return group names. The list is iterated in
         * order to translate the GID into group name using the getgrgid() function and allocating the newly translated
         * list in the Heap, linking it with the returning parameter. Afterwards the original list gets freed.
         */
        gname_linked_list *previous = NULL;
        int i;
        for (i = 0; i < ngroups; ++i) {
            struct group *group = getgrgid(group_list[i]);
            gname_linked_list *gnameLinkedList = malloc(sizeof(gnameLinkedList));
            gnameLinkedList->gname = strdup(group->gr_name);
            gnameLinkedList->next = NULL;
            if (previous != NULL) {
                previous->next = gnameLinkedList;
            } else {
                result.get_uname_reply_u.reply->linked_list = gnameLinkedList;
            }
            previous = gnameLinkedList;
        }
        free(group_list);
    }
    return &result;
}
